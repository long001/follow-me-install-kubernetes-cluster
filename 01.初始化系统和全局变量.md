tags: environment

# 01. 初始化系统和全局变量

<!-- TOC -->

- [01. 初始化系统和全局变量](#01-初始化系统和全局变量)
    - [集群规划](#集群规划)
    - [设置主机名](#设置主机名)
    - [添加节点信任关系](#添加节点信任关系)
    - [更新 PATH 变量](#更新-path-变量)
    - [安装依赖包](#安装依赖包)
    - [关闭防火墙](#关闭防火墙)
    - [关闭 swap 分区](#关闭-swap-分区)
    - [关闭 SELinux](#关闭-selinux)
    - [优化内核参数](#优化内核参数)
    - [设置系统时区](#设置系统时区)
    - [设置系统时钟同步](#设置系统时钟同步)
    - [关闭无关的服务](#关闭无关的服务)
    - [创建相关目录](#创建相关目录)
    - [分发集群配置参数脚本](#分发集群配置参数脚本)
    - [升级内核](#升级内核)
    - [参考](#参考)

<!-- /TOC -->

## 集群规划

三台阿里云按量付费ECS  
公网ip         私有ip 
47.101.58.106 172.19.70.100    
106.14.6.231  172.19.70.101  
47.100.190.21 172.19.70.102  

+ long-k8s-01：172.19.70.100
+ long-k8s-02：172.19.70.101
+ long-k8s-03：172.19.70.102

三台机器混合部署本文档的 etcd、master 集群和 woker 集群。  

如果没有特殊说明，需要在**所有节点**上执行本文档的初始化操作。  

xshell 连接三台 ECS ubuntu 18.04    
视需要使用 xshell 的 "发送输入到所有会话" 功能  

## 设置主机名

``` bash
hostnamectl set-hostname long-k8s-01   
```

如果 DNS 不支持主机名称解析，还需要在每台机器的 `/etc/hosts` 文件中添加主机名和 IP 的对应关系：

``` bash
cat >> /etc/hosts <<EOF
172.19.70.100 long-k8s-01
172.19.70.101 long-k8s-02
172.19.70.102 long-k8s-03
EOF
```

退出，重新登录 root 账号，可以看到主机名生效。

## 添加节点信任关系

配置 节点01 到02,03的 ssh 无密信仁    
本操作只需要在 zhangjun-k8s-01 节点上进行，设置 root 账户可以无密码登录**所有节点**   

使用示例
```
ssh -i ~/.ssh/long-20200508001.pem root@172.19.70.101 "ls -al /"  
```

## 更新 PATH 变量

``` bash
echo 'PATH=/opt/k8s/bin:$PATH' >>/root/.bashrc
source /root/.bashrc
```
+ `/opt/k8s/bin` 目录保存本文档下载安装的程序；

## 安装依赖包

``` bash
apt update 
apt install -y lrzsz chrony conntrack ipvsadm ipset jq iptables curl sysstat libseccomp-dev libseccomp2 seccomp wget socat git  
本文档的 kube-proxy 使用 ipvs 模式，ipvsadm 为 ipvs 的管理工具；   
etcd 集群各机器需要时间同步，chrony 用于系统时间同步；   
```
+ 本文档的 kube-proxy 使用 ipvs 模式，ipvsadm 为 ipvs 的管理工具；
+ etcd 集群各机器需要时间同步，chrony 用于系统时间同步；

## 关闭防火墙  

ubuntu 防火墙不需要设置   

## 关闭 swap 分区

关闭 swap 分区，否则kubelet 会启动失败(可以设置 kubelet 启动参数 --fail-swap-on 为 false 关闭 swap 检查)：

``` bash
swapoff -a
sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab 
```

## 关闭 SELinux

ubuntu selinux 不需要设置  

## 优化内核参数

``` bash
cat > kubernetes.conf <<EOF
net.bridge.bridge-nf-call-iptables=1
net.bridge.bridge-nf-call-ip6tables=1
net.ipv4.ip_forward=1
net.ipv4.tcp_tw_recycle=0
net.ipv4.neigh.default.gc_thresh1=1024
net.ipv4.neigh.default.gc_thresh1=2048
net.ipv4.neigh.default.gc_thresh1=4096
vm.swappiness=0
vm.overcommit_memory=1
vm.panic_on_oom=0
fs.inotify.max_user_instances=8192
fs.inotify.max_user_watches=1048576
fs.file-max=52706963
fs.nr_open=52706963
net.ipv6.conf.all.disable_ipv6=1
net.netfilter.nf_conntrack_max=2310720
EOF

cp kubernetes.conf  /etc/sysctl.d/kubernetes.conf
sysctl -p /etc/sysctl.d/kubernetes.conf
```
+ 关闭 tcp_tw_recycle，否则与 NAT 冲突，可能导致服务不通；ubuntu 默认没有开启这个

## 设置系统时区

``` bash
timedatectl set-timezone Asia/Shanghai
```

## 设置系统时钟同步

``` bash
systemctl enable chronyd # ubuntu 安装 chrony 后已设置了开机自启动 
systemctl start chronyd
```

在设置 chronyd 开机启动时，出现了"Failed to enable unit: Refusing to operate on linked unit file chronydl.service"，那么需要检测以下 chronyd 是否设置过了开机启动，    
systemctl is-enabled chronyd.service   
  
查看同步状态：  
``` bash
timedatectl status
```

输出：
``` text
       System clock synchronized: yes  表示时钟已同步 
systemd-timesyncd.service active: yes  表示开启了时钟同步服务
                 RTC in local TZ: yes
```

``` bash
# 将当前的 UTC 时间写入硬件时钟
timedatectl set-local-rtc 0
# 重启依赖于系统时间的服务
systemctl restart rsyslog
```

## 关闭无关的服务
ubuntu 不需要  

## 创建相关目录

创建目录：

``` bash
mkdir -p /opt/k8s/{bin,work} /etc/{kubernetes,etcd}/cert
```

## 分发集群配置参数脚本

后续使用的环境变量都定义在文件 [environment.sh](manifests/environment.sh) 中，请根据**自己的机器、网络情况**修改。然后拷贝到**所有**节点：

``` bash
cat > environment.sh <<EOF
#!/usr/bin/bash

# 生成 EncryptionConfig 所需的加密 key
export ENCRYPTION_KEY=$(head -c 32 /dev/urandom | base64)

# 集群各机器 IP 数组
export NODE_IPS=(172.19.70.100 172.19.70.101 172.19.70.102)

# 集群各 IP 对应的主机名数组
export NODE_NAMES=(long-k8s-01 long-k8s-02 long-k8s-03)

# etcd 集群服务地址列表
export ETCD_ENDPOINTS="https://172.19.70.100:2379,https://172.19.70.101:2379,https://172.19.70.102:2379"

# etcd 集群间通信的 IP 和端口
export ETCD_NODES="long-k8s-01=https://172.19.70.100:2380,long-k8s-02=https://172.19.70.101:2380,long-k8s-03=https://172.19.70.102:2380"

# kube-apiserver 的反向代理(kube-nginx)地址端口
export KUBE_APISERVER="https://127.0.0.1:8443"

# 节点间互联网络接口名称
export IFACE="eth0"

# etcd 数据目录
export ETCD_DATA_DIR="/data/k8s/etcd/data"

# etcd WAL 目录，建议是 SSD 磁盘分区，或者和 ETCD_DATA_DIR 不同的磁盘分区
export ETCD_WAL_DIR="/data/k8s/etcd/wal"

# k8s 各组件数据目录
export K8S_DIR="/data/k8s/k8s"

## DOCKER_DIR 和 CONTAINERD_DIR 二选一
# docker 数据目录
export DOCKER_DIR="/data/k8s/docker"

# containerd 数据目录
export CONTAINERD_DIR="/data/k8s/containerd"

## 以下参数一般不需要修改

# TLS Bootstrapping 使用的 Token，可以使用命令 head -c 16 /dev/urandom | od -An -t x | tr -d ' ' 生成
BOOTSTRAP_TOKEN="41f7e4ba8b7be874fcff18bf5cf41a7c"

# 最好使用 当前未用的网段 来定义服务网段和 Pod 网段

# 服务网段，部署前路由不可达，部署后集群内路由可达(kube-proxy 保证)
SERVICE_CIDR="10.254.0.0/16"

# Pod 网段，建议 /16 段地址，部署前路由不可达，部署后集群内路由可达(flanneld 保证)
CLUSTER_CIDR="172.30.0.0/16"

# 服务端口范围 (NodePort Range)
export NODE_PORT_RANGE="30000-32767"

# kubernetes 服务 IP (一般是 SERVICE_CIDR 中第一个IP)
export CLUSTER_KUBERNETES_SVC_IP="10.254.0.1"

# 集群 DNS 服务 IP (从 SERVICE_CIDR 中预分配)
export CLUSTER_DNS_SVC_IP="10.254.0.2"

# 集群 DNS 域名（末尾不带点号）
export CLUSTER_DNS_DOMAIN="cluster.local"

# 将二进制目录 /opt/k8s/bin 加到 PATH 中
export PATH=/opt/k8s/bin:$PATH
EOF
```

``` bash
source environment.sh # 先修改  

for node_ip in ${NODE_IPS[@]}
  do
    echo ">>> ${node_ip}"
    scp -i ~/.ssh/long-20200508001.pem environment.sh root@${node_ip}:/opt/k8s/bin/
    ssh -i ~/.ssh/long-20200508001.pem root@${node_ip} "chmod +x /opt/k8s/bin/*"
  done
```

## 升级内核
ubuntu 18.04 无需升级内核  
uname -r    
uname -a    

## 参考
1. 系统内核相关参数参考：https://docs.openshift.com/enterprise/3.2/admin_guide/overcommit.html
2. 3.10.x 内核 kmem bugs 相关的讨论和解决办法：
    1. https://github.com/kubernetes/kubernetes/issues/61937
    2. https://support.mesosphere.com/s/article/Critical-Issue-KMEM-MSPH-2018-0006
    3. https://pingcap.com/blog/try-to-fix-two-linux-kernel-bugs-while-testing-tidb-operator-in-k8s/